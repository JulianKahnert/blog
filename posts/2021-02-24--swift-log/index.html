<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="ju ka"/><link rel="canonical" href="https://juliankahnert.de/posts/2021-02-24--swift-log"/><meta name="twitter:url" content="https://juliankahnert.de/posts/2021-02-24--swift-log"/><meta name="og:url" content="https://juliankahnert.de/posts/2021-02-24--swift-log"/><title>Logging in Swift | ju ka</title><meta name="twitter:title" content="Logging in Swift | ju ka"/><meta name="og:title" content="Logging in Swift | ju ka"/><meta name="description" content="The Swift Server Work Group accepted a proposal of SwiftLog in 2019. Let's have a look at the techniques behind it and why we should use it in our codebase."/><meta name="twitter:description" content="The Swift Server Work Group accepted a proposal of SwiftLog in 2019. Let's have a look at the techniques behind it and why we should use it in our codebase."/><meta name="og:description" content="The Swift Server Work Group accepted a proposal of SwiftLog in 2019. Let's have a look at the techniques behind it and why we should use it in our codebase."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><link rel="stylesheet" href="/fonts.css" type="text/css"/><link rel="stylesheet" href="/code.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/img/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to ju ka"/><meta name="twitter:image" content="https://juliankahnert.de/img/memoji.png"/><meta name="og:image" content="https://juliankahnert.de/img/memoji.png"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">ju ka</a><nav><ul><li><a class="selected" href="/posts">My posts</a></li><li><a href="/about">About Me</a></li></ul></nav></div></header><hr/><div class="wrapper"><article><h1>Logging in Swift</h1><div class="content"><p>In this blogpost I want to talk about a logging framework in Swift.</p><p>The Swift Server Work Group (SSWG) <a href="https://swift.org/server/">accepted in 2019</a> the proposal of <a href="https://github.com/apple/swift-log">SwiftLog</a>. Let's have a deeper look at it now. ü§ì</p><h2>How?</h2><p>The <code>swift-log</code> module contains 2 parts, which we will have a look at in the next sections. Let's first have a look at how to produce log entries. Afterwards we dive into handling these logs and how there two parts are connected.</p><h3>Produce Logs</h3><p>To get started with logging, we first need an instance of <a href="https://github.com/apple/swift-log/blob/bda2661797277399ffa66c29701659c2ba02aba4/Sources/Logging/Logging.swift#L38"><code>Logger</code></a>.</p><p>We can create an instance of the <code>struct</code> by calling the <a href="https://github.com/apple/swift-log/blob/bda2661797277399ffa66c29701659c2ba02aba4/Sources/Logging/Logging.swift#L582"><code>public</code> initializer</a> like this:</p><pre><code><span class="keyword">import</span> Logging

<span class="keyword">let</span> logger = <span class="type">Logger</span>(label: <span class="string">"TestLogger"</span>)
</code></pre><p>I didn't want to repeat the <code>Logger</code> creation code so I came up with a little <code>protocol</code> and this default implementation:</p><pre><code><span class="keyword">import</span> Logging

<span class="keyword">public protocol</span> Log {
    <span class="keyword">var</span> log: <span class="type">Logger</span> { <span class="keyword">get</span> }
}

<span class="keyword">public extension</span> <span class="type">Log</span> {
    <span class="keyword">static let</span> log: <span class="type">Logger</span> {
        <span class="type">Logger</span>(label: <span class="type">String</span>(describing: <span class="keyword">self</span>))
    }

    <span class="keyword">var</span> log: <span class="type">Logger</span> {
        <span class="type">Self</span>.<span class="property">log</span>
    }
}
</code></pre><p>With this <code>protocol</code> in place you can use your <code>Logger</code> in a static or entity context üöÄ:</p><pre><code><span class="keyword">struct</span> ItemLoader: <span class="type">Log</span> {
    <span class="keyword">static func</span> create() -&gt; <span class="type">ItemLoader</span> {
        log.<span class="call">trace</span>(<span class="string">"Initializing ItemLoader!"</span>)
        <span class="keyword">return</span> <span class="type">ItemLoader</span>()
    }
    
    <span class="keyword">func</span> loadItem(completion: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) {
        log.<span class="call">trace</span>(<span class="string">"Start loading items..."</span>)
    }
}
</code></pre><p>Now we can use our logger and add it in our codebase. One thing you should keep in mind is, that this <code>Log</code> <code>protocol</code> uses a computed property that creates a new <code>Logger</code> instance on every call. This wasn't an issue for me since <code>Logger</code> is a lightweight <code>struct</code> but it creates a new <a href="https://github.com/apple/swift-log/blob/bda2661797277399ffa66c29701659c2ba02aba4/Sources/Logging/Logging.swift#L582"><code>LogHandler</code> from the <code>LoggingSystem</code> factory</a> which we'll come back later. So keep that caveat in mind if you use it on a hot code path üî•.</p><p>Since a little while I use <code>assertionFailure()</code> more and more in my codebases. That's why I added a little extension to <code>Logger</code>.</p><p><code>errorAndAssert()</code> and <code>criticalAndAssert()</code> are great ways to get notified directly in debug builds of your app. In your production code you will (only) receive an error in your logs since the <code>assertionFailure()</code> has no effect in release builds.</p><pre><code><span class="keyword">public extension</span> <span class="type">Logger</span> {
    <span class="keyword">func</span> errorAndAssert(<span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">Logger</span>.<span class="type">Message</span>,
                        metadata: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">Logger</span>.<span class="type">Metadata</span>? = <span class="keyword">nil</span>,
                        source: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span>? = <span class="keyword">nil</span>,
                        file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                        function: <span class="type">StaticString</span> = <span class="keyword">#function</span>,
                        line: <span class="type">UInt</span> = <span class="keyword">#line</span>) {
        <span class="call">error</span>(<span class="call">message</span>(), metadata: <span class="call">metadata</span>(), file: <span class="string">"</span>\(file)<span class="string">"</span>, function: <span class="string">"</span>\(function)<span class="string">"</span>, line: line)
        <span class="call">assertionFailure</span>(<span class="call">message</span>().<span class="property">description</span>, file: file, line: line)
    }

    <span class="keyword">func</span> criticalAndAssert(<span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">Logger</span>.<span class="type">Message</span>,
                           metadata: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">Logger</span>.<span class="type">Metadata</span>? = <span class="keyword">nil</span>,
                           source: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span>? = <span class="keyword">nil</span>,
                           file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                           function: <span class="type">StaticString</span> = <span class="keyword">#function</span>,
                           line: <span class="type">UInt</span> = <span class="keyword">#line</span>) {
        <span class="call">critical</span>(<span class="call">message</span>(), metadata: <span class="call">metadata</span>(), file: <span class="string">"</span>\(file)<span class="string">"</span>, function: <span class="string">"</span>\(function)<span class="string">"</span>, line: line)
        <span class="call">assertionFailure</span>(<span class="call">message</span>().<span class="property">description</span>, file: file, line: line)
    }
}
</code></pre><p><strong>One more thing: Metadata</strong></p><p>A good logging system should be able to handle metadata and forward it to the <code>LogHandler</code>.</p><p><code>swift-log</code> will get you covered ü•∑üèª! At first I was a little confused by the way the SSWG chose to handle metadata. If you want to add some metadata to your log entries I encourage you to have a look at <a href="https://github.com/apple/swift-log/blob/bda2661797277399ffa66c29701659c2ba02aba4/Sources/Logging/Logging.swift#L509">these examples</a>. Basically, you should write your metadata like this:</p><pre><code>log.<span class="call">trace</span>(<span class="string">"Some trace log entry."</span>, metadata: [<span class="string">"value"</span>: <span class="string">"42"</span>])
</code></pre><h3>Handle Logs</h3><p>So now we know how to send logs in the <em>blackbox</em> logging system but how will they get handled?</p><p>The framework introduces a <a href="https://github.com/apple/swift-log/blob/bda2661797277399ffa66c29701659c2ba02aba4/Sources/Logging/LogHandler.swift#L116"><code>LogHandler</code></a> for this purpose. There are already some <code>LogHandler</code> implementations mentioned in the <a href="https://github.com/apple/swift-log"><code>swift-log</code> README</a> which is a great starting point for your research.</p><p>In <a href="https://pdf-archiver.io">PDF Archiver</a> I use <a href="https://sentry.io/">Sentry.io</a> as a crash reporter. Since it really helps if you get a little context of the situation the user was in, while a crash has happend, I created the <a href="https://github.com/PDF-Archiver/PDF-Archiver/blob/bfc8cac12a3417f45302c45127020056b38568ea/ArchiveCore/Sources/ArchiveSharedConstants/Logging/SentryBreadcrumbLogger.swift#L11"><code>SentryBreadcrumbLogger</code></a>. It is an implementation of the <code>LogHandler</code> <code>protocol</code>. Essentially, it creates a <code>Breadcrumb</code> that contains all information that a entry log contains.</p><pre><code><span class="keyword">import</span> Sentry

<span class="keyword">let</span> crumb = <span class="type">Breadcrumb</span>()
crumb.<span class="property">level</span> = sentryLevel
crumb.<span class="property">category</span> = <span class="string">"</span>\(file) \(function)<span class="string">:</span>\(line)<span class="string">"</span>
crumb.<span class="property">message</span> = message.<span class="property">description</span>
crumb.<span class="property">data</span> = metadata?.<span class="call">reduce</span>(into: [<span class="type">String</span>: <span class="type">Any</span>]()) { (result, metadata) <span class="keyword">in</span>
    result[metadata.<span class="property">key</span>] = metadata.<span class="property">value</span>
}
crumb.<span class="property">timestamp</span> = <span class="type">Date</span>()
<span class="type">SentrySDK</span>.<span class="call">addBreadcrumb</span>(crumb: crumb)
</code></pre><p>But how do we connect the <code>Logger</code> with one (or even more) <code>LogHandler</code> implementations?</p><p>The <a href="https://github.com/apple/swift-log/blob/bda2661797277399ffa66c29701659c2ba02aba4/Sources/Logging/Logging.swift#L458"><code>LoggingSystem</code></a> will take care of this part. It's an <code>enum</code> that contains a <code>bootstrap</code> method which must only be called once. Let's have a look at an example first:</p><pre><code><span class="type">LoggingSystem</span>.<span class="call">bootstrap</span> { label <span class="keyword">in</span>
    # <span class="type">Factory</span> that makes a `<span class="type">StreamLogHandler</span>` to directs its output to `stdout`
    <span class="type">StreamLogHandler</span>.<span class="call">standardOutput</span>(label: label)
}
</code></pre><p>In this basic example the closure that was passed to the <code>bootstrap()</code> method defines the factory which creates a <code>LogHandler</code> when it is needed. You can even add multiple <code>LogHandler</code>s by wrapping them in a <a href="https://github.com/apple/swift-log/blob/bda2661797277399ffa66c29701659c2ba02aba4/Sources/Logging/Logging.swift#L726"><code>MultiplexLogHandler</code></a> which is great when you want to see your logs on the console and also send them to another entity, e.g. save them as breadcrumbs.</p><pre><code><span class="type">LoggingSystem</span>.<span class="call">bootstrap</span> { label <span class="keyword">in
    let</span> logLevel: <span class="type">Logger</span>.<span class="type">Level</span> = .<span class="dotAccess">trace</span>
    <span class="keyword">var</span> sysLogger = <span class="type">StreamLogHandler</span>.<span class="call">standardOutput</span>(label: label)
    sysLogger.<span class="property">logLevel</span> = logLevel
    <span class="keyword">let</span> sentryLogger = <span class="type">SentryBreadcrumbLogger</span>(metadata: [:], logLevel: logLevel)
    <span class="keyword">return</span> <span class="type">MultiplexLogHandler</span>([sysLogger, sentryLogger])
}
</code></pre><h2>Why?</h2><p>Ok let's recap: we know how to create a <code>Logger</code> instance and that <code>LoggingSystem.bootstrap()</code> defines a factory that returns a <code>LogHandler</code>.</p><p>You might ask yourself: <em>Why did you writing about a logging system?</em> ü§ì</p><p>Granted, this is not fancy topic but I like to learn on examples and maybe these ones are useful for someone else too. But I also want to add the statement: <strong>Your libraries should make use of <code>swift-log</code>!</strong></p><p>Your library can (or should) create internal <code>Logger</code> instances and create logs with different <a href="https://github.com/apple/swift-log/blob/bda2661797277399ffa66c29701659c2ba02aba4/Sources/Logging/Logging.swift#L543">log levels</a> as you think it is necessary. If some app developer uses your library and calls the <code>LoggingSystem.bootstrap()</code> function on startup, he will get all logs in one system and can pipe them to whatever <code>LogHandler</code> is useful for him. With <code>swift-log</code> the Swift community has a great API that can be used in different frameworks and across platforms!</p><h3>Pros</h3><ul><li>Standardized framework that everyone can use</li><li>Easy to implement (<code>LogHandler</code>)</li><li>Easy to use/write log entries (<code>Logger</code>)</li></ul><h3>Cons</h3><ul><li>High performance paths might better use <code>OSLog</code></li><li>Fixed log level for all subsystems, e.g. you can't set the level to error for a third-party library you use</li></ul><h2>Sources</h2><ul><li><a href="https://developer.apple.com/videos/play/wwdc2020/10168">WWDC2020: Explore logging in Swift</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2018/405">WWDC2018: Measuring Performance Using Logging</a></li></ul></div><span>Tagged with: </span><ul class="tag-list"><li class="tag-orange"><a href="/tags/log">log</a></li><li class="tag-blue"><a href="/tags/swift">swift</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a class="social-icon" target="_blank" href="/feed.rss"><img src="/img/logo-rss.svg"/></a><a class="social-icon" target="_blank" href="https://twitter.com/JulianKahnert"><img src="/img/logo-twitter.svg"/></a><a class="social-icon" target="_blank" href="https://github.com/JulianKahnert"><img src="/img/logo-github.svg"/></a><a class="social-icon" target="_blank" href="https://www.xing.com/profile/Julian_Kahnert"><img src="/img/logo-xing.svg"/></a></p></footer></body></html>